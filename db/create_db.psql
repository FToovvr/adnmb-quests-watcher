CREATE TABLE activity (
    id                      integer GENERATED BY DEFAULT AS IDENTITY,
    type                    text,
    -- 本次活动开始执行的时间
    run_at                  timestamptz NOT NULL,

    -- 本次抓取囊括了从何时开始的串/回应
    fetched_since           timestamptz,
    -- 下次抓取应该截止到的时间，能保证这之前的内容已经抓取到。
    -- 一般应为第一轮抓取时见到的第一串最后回应时间
    ensured_fetched_until   timestamptz,

    is_successful           boolean     NOT NULL,
    message                 text,

    -- 本次活动的统计信息：
    -- 上传了多少字节
    uploaded_bytes                  integer,
    -- 下载了多少字节
    downloaded_bytes                integer,
    -- 新记录了多少主题串
    newly_recorded_thread_count     integer,
    -- 在已有的主题串中，有多少记录了新的回应
    affected_thread_count           integer,
    -- 新记录了多少回应
    newly_recorded_post_count       integer,
    -- 调用了多少次获取版块页面的 API
    requested_board_page_count      integer,
    -- 调用了多少次获取串页面的 API
    requested_thread_page_count     integer,
    -- 有多少次以登录状态调用了获取串页面的 API
    logged_in_thread_request_count  integer,

    PRIMARY KEY (id)
);

CREATE INDEX idx__activity__run_at
    ON activity(run_at);
CREATE INDEX idx__activity__is_successful__run_before
    ON activity(is_successful, ensured_fetched_until);

CREATE TABLE post_base (
    id          integer,
    -- 照顾 thread_old_revision，不设为 NOT NULL
    created_at  timestamptz,
    -- 照顾 thread_old_revision，不设为 NOT NULL
    user_id     text,

    content                 text    NOT NULL,
    attachment_base         text,
    attachment_extension    text,
    name                    text,
    email                   text,
    title                   text,

    misc_fields             json
);

CREATE TABLE thread (
    -- +
    current_reply_count     integer,

    PRIMARY KEY (id)
) INHERITS (post_base);

CREATE INDEX idx__thread_user_id
    ON thread(user_id);
CREATE UNIQUE INDEX idx__thread__created_at__id
    ON thread(created_at, id);

CREATE TABLE thread_old_revision (

    -- 至少在这个时点之后就与这个版本的内容有不同了
    not_anymore_at_least_after  TIMESTAMPTZ,

    -- 旧版只记载了正文、名称、邮箱地址和标题的变化
    is_not_complete BOOLEAN DEFAULT FALSE,

    -- 从实用角度出发，不可能有两次修改在同一秒
    PRIMARY KEY (id, not_anymore_at_least_after),
    FOREIGN KEY (id) REFERENCES thread (id)
) INHERITS (post_base);

CREATE INDEX idx__thread_old_revision__not_anymore_at_least_after
    ON thread_old_revision (not_anymore_at_least_after);

CREATE TABLE thread_extra (
    id              integer,
    
    -- 如果串消失了，则这里保留较早的时间；否则保留最新的时间
    checked_at      TIMESTAMPTZ,

    is_disappeared  boolean,

    PRIMARY KEY (id),
    FOREIGN KEY (id) REFERENCES thread (id)
);

CREATE TABLE post (
    -- +
    parent_thread_id        integer     NOT NULL,

    PRIMARY KEY (id),
    FOREIGN KEY (parent_thread_id) REFERENCES thread(id)
) INHERITS (post_base);

CREATE UNIQUE INDEX idx__post__parent_thread_id__id
    ON post(parent_thread_id, id);
CREATE UNIQUE INDEX idx__post__parent_thread_id__created_at__id
    ON post(parent_thread_id, created_at, id);

-- TODO: 用 trigger 更新？
CREATE TABLE completion_registry_entry (
    id                          integer GENERATED BY DEFAULT AS IDENTITY,
    post_id                     integer,

    -- 由于有可能没见过，不作为外键了
    subject_thread_id           integer,

    has_blue_text_been_added    boolean DEFAULT FALSE,

    PRIMARY KEY (id),
    FOREIGN KEY (post_id) REFERENCES post(id)
);

CREATE INDEX idx__completion_registry_entry__post_id
    ON completion_registry_entry(post_id);
CREATE INDEX idx__completion_registry_entry_has_blue_text_been_added_subject_thread_id
    ON completion_registry_entry(has_blue_text_been_added, subject_thread_id);

CREATE TABLE publishing_trace (
    id              integer GENERATED BY DEFAULT AS IDENTITY,
    -- 所发报告的日期，而非发送时的日期
    date            date    UNIQUE,
    type            text    NOT NULL    CHECK (type IN ('trend', 'new_threads')),
    uuid            uuid    UNIQUE,

    attempts        integer    NOT NULL    DEFAULT 0,

    to_thread_id    integer,

    PRIMARY KEY (id)
);

CREATE UNIQUE INDEX idx__publishing_trace__date_type
    ON publishing_trace(date, type);

CREATE TABLE published_post (
    id              integer GENERATED BY DEFAULT AS IDENTITY,
    trace_id        integer NOT NULL,
    -- 指的是报告的第几页，不是在第几页
    page_number     integer NOT NULL,

    -- 如果找到所发的串则不为空
    reply_post_id   integer,
    -- 所发的串是第几个回应
    reply_offset    integer,

    PRIMARY KEY (id),
    FOREIGN KEY (trace_id) REFERENCES publishing_trace(id)
);

CREATE UNIQUE INDEX idx__published_post__trace_id_type_page_number
    ON published_post(trace_id, page_number);